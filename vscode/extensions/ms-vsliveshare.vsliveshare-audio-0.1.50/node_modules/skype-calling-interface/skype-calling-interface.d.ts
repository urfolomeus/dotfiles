// =============================================================================
// Typescript Definition file for component skype-calling-interface
//
// THIS FILE GOT AUTO-GENERATED BY generateDts.ts.
// =============================================================================

// -----------------------------------------------------------------------------
// Component 'skype-calling-interface'
// -----------------------------------------------------------------------------
declare module skype.calling {

export const enum CallState {
  None = 0,
  Notified = 1,
  Connecting = 2,
  Connected = 3,
  LocalHold = 4,
  RemoteHold = 5,
  Disconnecting = 6,
  Disconnected = 7,
  Observing = 8,
  EarlyMedia = 9,
  InLobby = 10
}

export const enum ServiceType {
  Testing = 0,
  MicrosoftWNS = 1,
  MicrosoftWP7NS = 2,
  AppleAPN = 3,
  GoogleAGCM = 4,
  Hotmail = 5,
  GoogleAC2DM = 6,
  Trouter = 7,
  Griffin = 8,
  ADM = 9,
  NNA = 10
}

export const enum TransferState {
  None = 0,       // Default/Initial state
  Started = 1,    // Set after transferor calls any transfer API
  Accepted = 2,   // Set after transferee has accepted
  Completed = 3,  // Set after transferee has completed (with success)
  Failed = 4      // Set after transferee has completed (with failure)
}

export const enum LightWeightMeetingState {
  None = 0,
  Connecting = 1,
  Connected = 2,
  Disconnecting = 3,
  Disconnected = 4
}

export const enum ParticipantState {
  None = 0,
  Connecting = 1,
  Ringing = 2,
  Connected = 3,
  Disconnected = 4,
  OnHold = 5,
  EarlyMedia = 6,
  InLobby = 7
}

export const enum ParticipantLightWeightMeetingRole {
  None = 0,
  Attendee = 1
}

export const enum ParticipantStateReason {
  None = 0,
  AddingFailed = 1,
  NoResponse = 2,
  Declined = 3,
  NotReachable = 4,
  Blocked = 5,
  NotFriendOrAuthorized = 6,
  CallLimitReached = 7,
  CallNotFound = 8,
  NetworkError = 9,
  MediaDroppedError = 10,
  OtherError = 11,
  PstnInsufficientFunds = 12,
  PstnSkypeoutAccountBlocked = 13,
  PstnCouldNotConnectToSkypeProxy = 14,
  PstnBlockedByUs = 15,
  PstnBlockedRegulatoryIndia = 16,
  PstnInvalidNumber = 17,
  PstnNumberForbidden = 18,
  Busy = 19,
  PstnCallTerminated = 20,
  PstnNumberUnavailable = 21,
  PstnEmergencyCallDenied = 22,
  Cancelled = 23,
  Dropped = 24, /* deprecated */
  PstnNoSubscriptionCover = 25,
  PstnCreditExpired = 26,
  PstnCreditExpiredButEnough = 27,
  EnterprisePstnInternalError = 28,
  EnterprisePstnUnavailable = 29,
  EnterprisePstnForbidden = 30,
  EnterprisePstnInvalidNumber = 31,
  EnterprisePstnMiscError = 32,
  Kicked = 33,
  NetworkRequestTimeoutError = 34,
  CallDoesNotExist = 35,
  MediaSetupFailure = 36,
  ServiceUnavailable = 37,
  SignalingError = 38,
  ConversationEstablishmentFailed = 39,
  TemporarilyUnavailable = 40,
  CannotConnectToNetworkError = 41,
  NoSignalingFromPeer = 42,
  ParticipantDoesNotExist = 43,
  DeniedInLobby = 44,
  TimedOutInLobby = 45,
}

export const enum CallSupport {
  Supported,
  BrowserNotSupported,
  IncompatibleVersions
}

export const enum FailureType {
  CallSetupFailed,
  CallDropped,
  Undefined
}

export interface QualityChangedEvent {
  type: QualityEventType;
  value: QualityLevel;
  isLocalSource: boolean;
  mediaType: MediaType;
}

export const enum QualityLevel {
  Unknown = 0,
  Good = 1,
  Poor = 2,
  Bad = 3
}

export const enum QualityEventType {
  NetworkSendQuality = 1,
  NetworkRecvQuality = 2,
  NetworkDelay = 3,
  NetworkBandwidthLow = 4,
  NetworkReconnect = 5,
  NetworkPacketLoss = 6,
  NetworkJitter = 7,
  NetworkRateMatching = 8,
  DeviceCaptureNotFunctioning = 9,
  DeviceRenderNotFunctioning = 10,
  DeviceRenderGlitches = 11,
  DeviceLowSNR = 12,
  DeviceLowSpeechLevel = 13,
  DeviceClipping = 14,
  DeviceEcho = 15,
  DeviceNearEndToEchoRatio = 16,
  DeviceHalfDuplexAec = 17,
  DeviceMultipleEndpoints = 18,
  DeviceHowling = 19,
  DeviceRenderZeroVolume = 20,
  DeviceRenderMute = 21,
  NetworkSendCatastrophic = 22,
  NetworkRecvCatastrophic = 23,
  CpuInsufficient = 24,
  DeviceCaptureMute = 25,
  DeviceCaptureNotMuteButSilent = 26,
  DeviceSpeakWhileMuted = 27,
  VideoVbssRendered = 28,
  NetworkEthernetInterfaceUsed = 29,
  NetworkWlanInterfaceUsed = 30,
  NetworkWwanInterfaceUsed = 31,
  NetworkRelaysNotReachable = 32,
  VideoCapturerDeviceStartFailed = 33,
  VideoCapturerDeviceStartTimedOut = 34,
  VideoCapturerDeviceStartFailureLackSystemRes = 35,
  VideoCapturerDeviceStartFailureMFResConflict = 36,
  NoNetwork = 37,
  NetworkNotWorking = 38,
  DeviceCaptureNotFunctioningDeviceInUse = 39,
  DeviceRenderNotFunctioningDeviceInUse = 40,
  DeviceCaptureNotFunctioningAudioSrvNotRunning = 41,
  DeviceRenderNotFunctioningAudioSrvNotRunning = 42,
  ZeroCaptureDevicesEnumerated = 43,
  ZeroRenderDevicesEnumerated = 44
}

export const enum StreamType {
  Video = 0,
  ScreenSharing = 1
}

export const enum MuteScope {
  All = 0,
  Specified = 1
}

export const enum CallingIntent {
  Incoming,
  Outgoing,
  WarmPush
}

export type EventCallback = (...args: any[]) => void;
export type ObservableChangedCallback = () => void;

export interface IDisposable {
  dispose(): void;
}

export interface IObservableObject<T> {
  changed(callback: ObservableChangedCallback): IDisposable;
  on<P extends keyof T>(event: P, callback: T[P]): IDisposable;
  once<P extends keyof T>(event: P, callback: T[P]): IDisposable;
}

export const enum ConnectionType {
  AllSupported = 0,
  NoDirectConnection,
}

export interface IncomingCallPayload {
  conversationId: string;
  messageId: string;
  callerId: string;
  convoCallId: string;
  participantId?: string;
  isMultiParty: boolean;
  ngcCall: boolean;
  body: {
    evt?: number;
    gp: string;
    nsp: string;
  };
  transferorId?: string;
  transferorType?: string;
  transferorDisplayName?: string;
  callType?: IncomingCallType;
  videoCall: boolean;
  launchTime: number;
  pushReceivedTime: number;
  registrationId: string;
  callKey?: string;
  connectionType?: ConnectionType;
  callQueueInfo?: CallQueueInfo;
}

export interface IStream extends IObservableObject<{}> {
  isAvailable: boolean;
  isStreaming: boolean;
  participantId?: string;
  endpointId?: string;
  isActive(): boolean;
}

export interface Size {
  width: number;
  height: number;
}

export const enum ScalingMode {
  Stretch,
  Crop,
  Fit
}

export const enum RendererErrorType {
  Unknown = -1,
  CaptureError = 0,
  RendererFailed = 1,
  RendererFailedGpuContext = 2,
}

export interface IRendererError {
  reason: any;
  errorType: RendererErrorType;
}

export const enum RendererType {
  Unknown = -1,
  VideoElement = 0,
  WebGLv1 = 1,
  WebGLv2 = 2,
  Pepper = 3,
  ReactNative = 4
}

export const enum FrameType {
  Unknown = -1,
  None = 0,
  Software = 1,
  Hardware = 2,
}

export type RendererStats = {
  framesDropped: number;
  framesTotal: number;
}

export interface IRendererEvents {
  frameTypeChanged: (frameType: FrameType) => void;
}

export interface IVideoFrame {
  getSize(): Size;
  isMirrored(): boolean;
}

export interface IRenderer extends IDisposable, IObservableObject<IRendererEvents> {
  readonly isRendering: boolean;
  readonly streamSize: Size;
  readonly rendererType: RendererType;
  readonly frameType: FrameType;

  captureFrame(timeoutMs: number): Promise<IVideoFrame>;
  getStats(): Promise<RendererStats>;
  setScalingMode(scalingMode: ScalingMode): Promise<void>;
}

export type FrameSink = any;

export type ElectronElement = {
  renderer: any;
};

export interface RNElement {
  attachVideo(key: number, position: CameraPosition, options: StartStreamOptions): Promise<void>;
  detachVideo(): Promise<void>;
  updateScalingMode(scalingMode: ScalingMode): Promise<void>;
}

export type IRenderTarget = HTMLElement | ElectronElement | RNElement;

export const enum MediaType {
  Audio,
  Video,
  PanoramicVideo,
  ScreenShare,
  Data
}

export const enum MediaDirection {
  Disabled,
  ReceiveOnly,
  SendOnly,
  Inactive,
  Bidirectional
}

export const enum MediaNegotiationStatusCode {
  Succeeded,
  ErrorLocalInternal,
  ErrorRemoteInternal,
  OfferNotAcceptable,
  OfferDeclined,
  LocalCancel,
  RemoteCancel,
  FailedNoRetry,
  Terminated,
  GeneralFailure
}

export const enum AnswerMediaType {
  AnswerWithAudioOnly,
  AnswerWithAudioVideo,
  AnswerWithScreenshareOnly
}

export const enum MediaStreamDirection {
  Receive,
  Send
}

export const enum MediaStreamState {
  Started,
  Inactive,
  Active,
  Stopped,
  Failed
}

// EndpointType is used to represent the identity type of a user/bot endpoint
export type EndpointType = 'default' | 'lync' | 'voicemail';

export type ParticipantRosterRole = 'admin' | 'guest';

// Capabilities represent a user's ability to perform an action in the call. This is represented by a bitmask.
export type Capabilities = {
  canConference: boolean;   // Indicates the ability for a participant to be part of a conference call
  canShareScreen: boolean;  // Indicates the ability for a participant to share and/or view screen
  canMerge: boolean;        // Indicates the ability to merge the participant to another 1-1 or group call
}

export const enum ControlState {
  None,
  RequestSent,
  WaitingForControlAck,
  RemoteControlling,
  LocalControlling,
  WaitingForTerminateAck
}

export const enum ControlTerminatedReason {
  None,
  SharerDenied,
  SharerNoResponse,
  SharerBusy,
  AckTimeout,
  SharerTerminated,
  ViewerTerminated,
  DataChannelError,
  ViewerCancelled,
  SharerControlDisabled
}

export interface MediaStreamInfo {
  mediaType: MediaType;
  mediaDirection: MediaStreamDirection;
  mediaStreamState: MediaStreamState;
}

export interface StartStreamOptions {
  scalingMode: ScalingMode;
  transparent: boolean;
}

export interface ICallParticipantStream extends IStream, IDisposable, IObservableObject<{}> {
  id: number;
  type: StreamType;
  rank: number;

  start(target: IRenderTarget, options?: StartStreamOptions): Promise<IRenderer>;
  stop(): Promise<void>;
}

// AdmissionType is used to define the type of users allowed in to the meeting
export type AdmissionType = 'default' | 'anonymous' | 'open';

// Allowed Pstn Conferencing Dialout Type
export type PstnConferencingDialoutType = 'disabled' | 'domesticOnly' | 'internationalAndDomestic';

// Allowed App Desktop sharing type
export type AppDesktopSharingType = 'none' | 'singleApplication' | 'desktop';

export interface MeetingCapabilities {
  allowAnonymousUsersToDialOut?: boolean;
  admissionType?: AdmissionType;
  allowAnonymousUsersToStartMeeting?: boolean;
  admitAnonymousUsersByDefault?: boolean;
  appDesktopSharingType?: AppDesktopSharingType;
  allowVideo?: boolean;
  allowDialinConferencing?: boolean;
  allowCloudRecording?: boolean;
  pstnConferencingDialoutType?: PstnConferencingDialoutType;
  [key: string]: any;
}

export interface MeetingDetails {
  capabilities?: MeetingCapabilities;
  invitation?: string;
  [key: string]: any;
}

// This is for debuging and diagnosis only and NOT to be used for functional error mapping.
export interface CallEndDiagnosticsInfo {
  callControllerCode?: number;
  callControllerSubCode?: number;
}

export type CapabilitiesValue = 'enabled' | 'disabled';

export interface CallParticipantCapabilities {
  serverMuteUnmute?: CapabilitiesValue;
}

export interface CallParticipantEndpointDetails {
  clientVersion: string;
  participantId: string;  // unique ID per connection to the call
  endpointId: string;     // unique ID per user in the call
  endpointType: EndpointType;  // The endpoint type for the current endpoint.
  endpointMetadata: any;  // application-specific blob
  originalId?: string;    // original id from the call me back scenario.
  capabilities?: CallParticipantCapabilities; // capabilities blob
}

export interface CallParticipantEndpoints {
  endpointDetails: CallParticipantEndpointDetails[];
}

export interface CallParticipantBalanceUpdateSender {
  endpointId: string;   // Sender's endpoint id.
}

export interface CallParticipantBalanceUpdate {
  accountBalance?: number;          // Account balance.
  accountCurrency?: string;         // Should be same as account currency at the time of the call.
  cdrIdString?: string;             // Pstn call debuginfo string (to report quality problems).
  emergencyCallCountry?: string;    // Country Code in case of emergency call.
  limitingFactor?: number;          // Used in conjunction with secondsLeft, specifies the context for the publication of that value; e.g. use of a credit-based calling plan.
  minutePrice?: number;             // Price per minute denominated in accountCurrency and adjusted by pricePrecision.
  pricePrecision?: number;          // Decimal points in minutePrice.
  secondsLeft?: number;             // Number of seconds left for call leg.
  sender: CallParticipantBalanceUpdateSender;   // Sender of this balance update message.
}

export interface CallParticipantBalanceUpdateMap {
  [endpointId: string]: CallParticipantBalanceUpdate;
}

export type CallParticipantStreamMap = {
  // StreamType -> ICallParticipantStream[]
  [type: number]: ICallParticipantStream[];
};

export interface ICallParticipant extends IDisposable, IObservableObject<{}> {
  // MRI formatted identity for the participant. Ex: 8:batman;aliases=2:darkknight@gotham.net
  id: string;
  displayName: string;
  role?: ParticipantRosterRole;
  tenantId?: string;

  // Represents active speaker bit for the participant.Non-zero value indicates active and 0 means inactive.
  voiceLevel: number;

  // Indicates if this person is muted in a group call. This property is applicable only for group calls.
  // This is the aggregated mute state for the user across all endpoints.
  // i.e isServerMuted is true only if participant is muted on all the endpoints and false otherwise.
  isServerMuted: boolean;

  // The call state for the participant. stateReason represents the end state error for the participant.
  state: ParticipantState;
  stateReason: ParticipantStateReason;
  lightWeightMeetingRole?: ParticipantLightWeightMeetingRole;

  // Streams for the participant.
  streams: CallParticipantStreamMap;

  // The capabilities of the participant in a call
  participantCapabilities: Capabilities;

  // Indicates the "onbehalfof" relationship when this participant is represented by an overloaded identity.
  // Ex: in case of call forwarding, id will contain original target but acceptedBy contains final forwarded target.
  acceptedBy: string;

  // All the active  endpoints associated with the participant.
  endpoints?: CallParticipantEndpoints;
  contentSharingRole: ParticipantContentSharingRole;

  // Call termination diagnostics code/subcode. This is exposed to enable client to capture additional
  // telemetry for alerting and diagnosis only and not for functional reasons.
  callEndDiagnosticsInfo?: CallEndDiagnosticsInfo;

  // Most recent balance update, if any, associated with the participant.
  balanceUpdates: CallParticipantBalanceUpdateMap;
}

export interface DominantSpeakerInfo {
  speakerList: string[];
  timestamp: Date;
}

export const enum TerminatedReason {
  Undefined = 0,
  Success = 1,
  NoNgcEndpoint = 2,
  NetworkError = 3, /* More general network error like losing trouter connectivity */
  MediaDroppedError = 4,
  BadRequest = 5,
  CallEstablishmentTimeout = 6,
  CallSetupError = 7,
  NoPermission = 8,
  Missed = 9,
  Declined = 10,
  Busy = 11,
  Cancelled = 12,
  Dropped = 13, /* deprecated */
  PstnInsufficientFunds = 14,
  PstnSkypeoutAccountBlocked = 15,
  PstnCouldNotConnectToSkypeProxy = 16,
  PstnBlockedByUs = 17,
  PstnBlockedRegulatoryIndia = 18,
  PstnInvalidNumber = 19,
  PstnNumberForbidden = 20,
  PstnCallTerminated = 21,
  PstnNumberUnavailable = 22,
  PstnEmergencyCallDenied = 23,
  CallNotFound = 24,
  LocalError = 25,
  NotAcceptableHere = 26,
  CallForwarded = 27,
  CallForwardedToVoicemail = 28,
  SkypeTokenError = 29,
  CallAccepted = 30,
  LocalHttpStackError = 31, /* Error provided by js http stack */
  UnknownError = 32,
  PstnNoSubscriptionCover = 33,
  SessionNotFound = 34,
  SessionTimedOut = 35,
  PstnCreditExpired = 36,
  PstnCreditExpiredButEnough = 37,
  RetargetNotSupported = 38,
  EnterprisePstnInternalError = 39,
  EnterprisePstnUnavailable = 40,
  EnterprisePstnForbidden = 41,
  EnterprisePstnInvalidNumber = 42,
  EnterprisePstnMiscError = 43,
  Kicked = 44,
  NetworkRequestTimeoutError = 45, /* When receiving a timeout on a network request */
  CallDoesNotExist = 46,
  MediaSetupFailure = 47, /* When failing to setup media due to timeout or answer errors */
  ServiceUnavailable = 48,  /* When the calling service is unavailable */
  SignalingError = 49,  /* When receiving errors from conversation service */
  ConversationEstablishmentFailed = 50, /* When establishing the conversation has failed */
  TemporarilyUnavailable = 51,  /* When the callee is temporarily unavailable */
  CannotConnectToNetworkError = 52, /* When connecting to the internet has failed */
  MediaRelayWhiteListingIssue = 53,
  NoSignalingFromPeer = 54,
  DeniedInLobby = 55, /* User in the lobby was denied */
  TimedOutInLobby = 56, /* If user in lobby was not admitted for extended time, and service ended the call with user due to timeout*/
  CallFailedConflict = 57, // outgoing call failure, there was incoming call from same person and it should be (auto) accepted
}

export const enum DtmfTone {
  Num0 = 0,
  Num1 = 1,
  Num2 = 2,
  Num3 = 3,
  Num4 = 4,
  Num5 = 5,
  Num6 = 6,
  Num7 = 7,
  Num8 = 8,
  Num9 = 9,
  Star = 10,
  Pound = 11,
  A = 12,
  B = 13,
  C = 14,
  D = 15,
  Flash = 16
}

export const enum MediaPeerType {
  ConsumerTwoParty = 0,
  ConsumerPstn = 1,
  ConsumerMultiParty = 2,
  EnterpriseTwoPartyOnlineOnly = 3,
  EnterpriseTwoPartyHybrid = 4,
  EnterpriseMultiParty = 5,
  EnterprisePstnOnlineOnly = 6,
  EnterprisePstnHybrid = 7,
  EnterpriseFederated = 8,
  EnterpriseUnknown = 9
}

//represents MM_AUDIO_USAGE_MODE in msrtc
export const enum AudioUsageMode {
  Default,
  LongrangeSpeaker,
  Auditorium
}

// This is passed to 'join' calls and comes from ThreadUpdate chat messages
export interface SkypeConversationLiveState {
  conversationUrl: string;      // NOTE: This is actually for calling (bad words)
  conversationId: string;       // NOTE: This is actually a call ID (bad words)
  conversationType?: string;    // Indicates type ex: 'cast'
  groupCallInitiator?: string;
  expiration?: number;
  status?: string;
  isHostless?: boolean;
}

export const enum CallType {
  Unknown = -1,
  P2P = 1,
  Conference = 2
}

export const enum CallMeetingType {
  Unknown = -1,
  Private = 1,
  Channel = 2
}

export interface MeetingInfo {
  tenantId: string;
  organizerId: string;
  meetingType?: CallMeetingType;
  replyChainMessageId?: string;
}

export interface SessionTerminatedReason {
  terminatedReason: TerminatedReason;
  terminatedReasonCode: number;
  terminatedReasonSubCode: number;
}

export interface CallAcknowledgeResult {
  code: CallAcknowledgeResultCode;
  success?: boolean;
  fatal?: boolean;
}

export const enum CallAcknowledgeResultCode {
  BadNotificationPayload,       // Fatal error: Indicates the input payload to acknowledge is improperly formatted.
  CallSetupSucceeded,           // Success: Indicates push handling succeeded and incoming call will ring.
  CallSetupFailed,              // Fatal error: Indicates push handling failed and incoming call will not ring.
  BadNotificationEventType,     // Fatal error: The event id is not a supported event. Supported values 105, 107, 109, 111.
  CallAlreadyExists,            // Non-fatal error: indicates client already is in the middle of joining the call.
  CallFailedCannotConnect,      // Fatal error: indicates client couldn't setup due to network issues.
  CallFailedNoSignaling,        // Fatal error: indicates client couldn't start call signaling.
  CallFailedConflict,           // Non-fatal error: indicates there is already an outgoing to same user.
  CallFailedPushIgnored,        // Non-fatal error: the push was ignored.
  CallFailedAnsweredElsewhere,  // Non-fatal error: the call was already answered elsewhere before this endpoint could process the push.
  CallFailedCallAlreadyEnded,   // Non-fatal error: call was either canceled by caller or timed out.
  CallSetupInProgress,          // The call push was processed successfully and another callback will be raised when the push processing completes with result code.
}

export interface ILightWeightMeeting extends IObservableObject<{}> {
  state: LightWeightMeetingState;
  stateReason: SessionTerminatedReason;
  metadata: any; // Metadata contains information about if VBSS stream is active for download and the URLs for retrieving the data
}

export interface BroadcastContext {
  // To be filled based on the definition used by service
}

export interface BroadcastState {
  // To be filled based on the definition used by the broadcast controller
  // This state object is send us by the Broadcast Modality controller as part of metadata change event.
  // It capture the state of composer service at that time, what sources it is subscribed to and results of recent commands executed.
}

export interface BroadcastLayout {
  // Will populate later when we have more concrete definition
}

/**
 * [Internal] Once we move to ts-calling, we should be ok to get rid of this.
 * This is currently just used in BroadcastMeeting class.
 */
export interface BroadcastMetadata {
  broadcastControllerUrl?: string;
  broadcastStateCallbackUrl?: string;
  broadcastState?: BroadcastState
}

export const enum BroadcastModalityState {
  None = 0,
  Ringing = 1,
  Connecting = 2,
  Connected = 3,
  Disconnected = 4
}

export interface IBroadcastMeeting extends IObservableObject<{}> {
  modalityState: BroadcastModalityState;
  broadcastState: BroadcastState;

  /**
   * Expose role of the event team member
   */
  role: string;

  setLayout(layout: BroadcastLayout): Promise<void>;
  start(): Promise<void>;
  stop(): Promise<void>;
  joinModality(): Promise<void>;

  // These are the internal methods/variables and will be removed once we move from teams repo
  // Discussed with swapna, we refer class (instead of interface) in the concrete implementation of call object
  // These properties/method can be added in class and removed from interface
  context: BroadcastContext;
  // Will be called by call object to notify metadata has changed
  metadataChanged(rawMetadata: string): void;
}

export interface ICallRegistryEvents {
  skypeTokenRequired: (invalidToken: string) => void;
  callAdded: (call: ICall) => void;
  callRemoved: (call: ICall) => void;
}

export interface ICallRegistry extends IObservableObject<ICallRegistryEvents> {
  calls: ICall[];

  init(skypeIdentity: SkypeIdentity): Promise<void>;

  uninit(): Promise<void>;

  // localParticipantId allows using a specific GUID for outbound calls,
  // otherwise a random one will be assigned.
  createCall(threadId: string, callId?: string, localParticipantId?: string): ICall;

  getCall(callId: string, localParticipantId: string): ICall;

  deleteCall(call: ICall, final?: boolean): boolean;

  // Gets debug information for the specified call (if provided), or the most recent available call
  debugInformation(call?: ICall): Promise<string>;

  updateSkypeToken(skypeToken: string): void;
}

export interface CallInitOptions {
  mediaPeerType: MediaPeerType;
  threadId: string;
  messageId?: string;
  enableGroupCallMeetupGeneration?: boolean;
  meetingInfo?: MeetingInfo;
  transferContext?: ICallTransferContext<any>;
  broadcastContext?: BroadcastContext;
  endpointMetadata?: string;
  onBehalfOf?: string;
  emergencyContent?: string;
}

//----------------------------------------------------------------------------
// Modality                  MediaDirection
//----------------------------------------------------------------------------
// audioDirection       Bidirectional - default
//
//                      Inactive - if audio is not needed
//
//                      Disabled - NotAllowed
//----------------------------------------------------------------------------
// videodirection       Bidirectional - VideoCall
//
//                      ReceiveOnly - default
//                     
//                      Inactive - if video is not needed in group calls
//                      Disabled - if video is not needed in 1-1 calls
//
//                      SendOnly - NotAllowed
//----------------------------------------------------------------------------
// screenshareDirection SendOnly - if screenshare is to be initiated
//
//                      ReceiveOnly - default for groupCalls
//                      Disabled - default for 1-1 calls
//
//                      Bidirectional, Inactive - NotAllowed
//----------------------------------------------------------------------------
// datachannelDirection Bidirectional - if datachannel is needed
//
//                      Disabled - default
//
//                      SendOnly, ReceiveOnly, Inactive - NotAllowed
//----------------------------------------------------------------------------
export interface CallStartOptions {
  ringOthers?: boolean;
  withVideo?: boolean; // to be deprecated
  audioDirection?: MediaDirection;
  videoDirection?: MediaDirection;
  screenshareDirection?: MediaDirection;
  datachannelDirection?: MediaDirection;
  // Affects pluginless stack only
  muted?: boolean;
  label?: string;
  isCast?: boolean;
  callKey?: string;
  encryptedKey?: string;
  connectionType?: ConnectionType;
}

export interface CallAcceptOptions {
  withVideo?: boolean;// to be deprecated
  answerMediaType?: AnswerMediaType;
  // Affects pluginless stack only
  muted?: boolean;
}

export type VoicemailResourcePath = 'voicememo' | 'greeting' | 'voicemail' | '';

export interface CallVoicemailStartOptions {
  // Voicemail resource for different voicemail scenarios.
  // For call to other's voicemail, use "voicememo".
  // For setting or listening to self greeting, use "greeting".
  // For listening to self voicemail message, use empty string.
  // For playing a specific self voicemail message, use "voicemail"
  voicemailResourcePath?: VoicemailResourcePath;
  // Specify a particular voicemail item for the voicemail service to play.  This is
  // only applicable to the play a specific self voicemail message scenario
  voicemailItemId?: string;
}

// participantInvitationData: JSON formatted blob
export interface AddParticipantPayload {
  threadId?: string;
  messageId?: string;
  sipUri?: string;
  participantInvitationData?: any;
}

export type IncomingCallType = "default" | "forward" | "transfer";
export type ForwardingDestinationType = "user" | "team" | "delegates" | "voicemail";
export type TransferorType = "unknown" | "delegator" | "teamMember";
export interface ICallEvents {
  callIdChanged: (correlationId: string) => void;
  callLegIdChanged: (participantId: string) => void;
  callQualityChanged: (event: QualityChangedEvent) => void;
  callStateChanged: () => void;
  mediaConnectionFailed: () => void;
  mediaConnectionWhitelistingWarning: () => void;
  mediaStreamStateChanged: (info?: MediaStreamInfo) => void;
  sharingDropped: () => void;
  serverMutedChanged: (isServerMuted: boolean) => void;
  sharingStolen: () => void;
  statsReported: () => void;
  transferRequested: (info: CallTransferInfo<any>) => void;
  userActivityChanged: () => void;
  contentSharingChanged: () => void;
  lightWeightMeetingChanged: () => void;
  broadcastMetadataChanged: () => void;
  replacementRequested: (message: any) => void;
  participantAdded: (participant: ICallParticipant) => void;
  participantRemoved: (participant: ICallParticipant) => void;
  participantUpdated: (participant: ICallParticipant) => void;
}

export interface ICall extends IObservableObject<ICallEvents> {
  // The globally unique guid representing the call.
  callId: string;

  // The thread associated with the call.
  threadId: string;
  callType: CallType;
  callerMri: string;

  // Endpoint id unique endpoint for the device and does not change across calls.
  endpointId: string;

  // This is a session id for the call. The id can change for the same call if user joins the same call again.
  participantId: string;

  // The local call states.
  state: CallState;
  transferState: TransferState;
  participants: ICallParticipant[];
  dominantSpeakerInfo: DominantSpeakerInfo;
  callStartedAt: Date;
  callHeldAt?: Date;
  isAudioStreamConnected?: boolean;

  // Active media streams from the user's other endpoints.
  mediaStreams: CallParticipantStreamMap;

  // This represents the local mute state.
  isMuted: boolean;

  // Indicates if the local endpoint is also muted on the service in a group call. This property is applicable only for group calls.
  // This is the aggregated mute state for the user across all endpoints.
  // i.e isServerMuted is true only if participant is muted on all endpoints and false otherwise.
  isServerMuted: boolean;

  // This represents the local mute state for speaker or other audio output
  isSpeakerMuted: boolean;

  // TODO: should be removed and represented on local call object.
  // Used to identify the conversation for Teams client because threadId will be null for a 1:1 call.
  conversationId?: string;

  // T0D0: should be removed and states must be represented on local video and screen share object itself.
  isVideoOn: boolean;
  isScreenSharingOn: boolean;
  terminatedReason: TerminatedReason;
  failureType: FailureType;
  messageId?: string;
  isCast?: boolean;
  label?: string;
  isHostless?: boolean;
  endpoints?: CallParticipantEndpoints;
  meetingDetails?: MeetingDetails;
  role?: ParticipantRosterRole;
  tenantId?: string;
  transferorMri?: string;
  transferorDisplayName? : string;
  transferorType?: TransferorType;
  onBehalfOfMri?: string;
  callQueueInfo?: CallQueueInfo;
  incomingCallType?: IncomingCallType;
  isIncomingOneOnOneVideoCall?: boolean;
  forwardingDestinationType?: ForwardingDestinationType;
  optimalVideoCount?: number;
  contentSharingSessions: IContentSharingSession[];
  lightWeightMeeting?: ILightWeightMeeting;
  screenSharingControl?: IScreenSharingControl;
  broadcastMeeting?: IBroadcastMeeting;
  broadcastMetadata?: BroadcastMetadata;
  holographicInteractionControl?: IHolographicInteractionControl;

  init(callInitOptions: CallInitOptions): void;
  join(context: SkypeConversationLiveState, callStartOptions: CallStartOptions): Promise<void>;
  joinLightWeightMeeting(context: SkypeConversationLiveState, callStartOptions: CallStartOptions): Promise<void>;
  joinCallWithoutCallModality(context: SkypeConversationLiveState, callStartOptions?: CallStartOptions): Promise<void>;
  start(callStartOptions: CallStartOptions): Promise<void>;
  startLightWeightMeeting(callStartOptions: CallStartOptions): Promise<void>;
  startCallToVoicemail(callStartOptions: CallVoicemailStartOptions): Promise<void>;
  acknowledge(incomingCall: IncomingCallPayload): Promise<CallAcknowledgeResult>;
  accept(callAcceptOptions: CallAcceptOptions): Promise<void>;
  reject(): Promise<void>;
  admitParticipant(participantId: string): Promise<void>;
  addParticipant(participantId: string, payload?: AddParticipantPayload): Promise<ICallParticipant>;

  // Initiates a call me back scenario.
  // The parameter participantMri is the to user mri.
  // The parameter assertedId is the mri of the callMeBack operation initiator.
  // AssertedMri is made an optional parameter to support future extensibility of the API.
  // If assertedMri is not specified, it would be default to the callMebBack operation initiator's mri.
  callMeBack(participantMri: string, assertedMri?: string): Promise<void>;
  removeParticipant(participantId: string): Promise<void>;
  stop(forEveryone?: boolean): Promise<void>;

  // Mutes and unmutes the local endpoint's microphone
  mute(): Promise<void>;
  unmute(): Promise<void>;

  // Mutes the remote participants' microsphone.
  // When MuteScope=All and input participant list is empty, everyone excluding self are muted.
  // When MuteScope=All and input participant list is not empty, everyone excluding the input participants and self are muted.
  // When MuteScope=Specified, the specified input list of participants alone are muted.
  muteParticipants(muteScope: MuteScope, callParticipants: ICallParticipant[]): Promise<void>;

  // Mutes and unmutes the local speaker/audio output
  muteSpeaker(): Promise<void>;
  unmuteSpeaker(): Promise<void>;

  hold(): Promise<void>;
  unhold(): Promise<void>;
  updateEndpointMetadata(endpointMetadata: string): Promise<void>;
  sendDtmfTone(dtmfTone: DtmfTone): Promise<void>;
  setVideoContainer(node: IRenderTarget, options?: StartStreamOptions): Promise<void>;
  startVideo(): Promise<void>;
  stopVideo(): Promise<void>;
  startScreenSharing(source?: ISharingSource): Promise<void>;
  stopScreenSharing(): Promise<void>;
  shareSystemSound(enable: boolean): Promise<void>;
  disposeLocalVideoRenderer(): Promise<void>;
  transferCall(transferTargetMri: string): Promise<TerminatedReason>;
  callSafeTransfer(transferTargetMri: string): Promise<TerminatedReason>;
  callConsultativeTransfer(callWithTarget: ICall): Promise<TerminatedReason>;
  startAudio(): Promise<MediaNegotiationStatusCode>;
  stopAudio(): Promise<MediaNegotiationStatusCode>;

  // Technical information is JSON formatted string used for debugging purpose only.
  // This API also blocks and can cause perf issues if called too often so recommend calling
  // it no less than 10 second frequency.
  getTechnicalInformationJson(): Promise<string>;

  createContentSharingSession(contentSharingGuid: string, contentSharingIdentity: string, subject?: string, initialContentSharingSessionState?: string): Promise<IContentSharingSession>;

  //The method allows to configure audio usage mode for current call.
  setAudioUsageMode(audioUsageMode: AudioUsageMode): Promise<void>;

  // Initiates reconnect
  // Used for testing purposes
  reconnect(): Promise<void>;

  // CQF
  provideCallQualityFeedback(questionaryId: string, trackingReason: string, rating: number, problemTokens: string): Promise<void>;
}

export interface SkypeIdentity {
  id: string;
  displayName: string;
  tokenProvider: () => Promise<string>;
  sipUri?: string;
}

export type CallQueueInfo = {
  type: string,
  details: {
    id: string,
    displayName: string,
  },
  onBehalfOf: {
    id: string;
    displayName: string;
  }
}

export const enum DeviceType {
  Camera = 1,
  Microphone = 2,
  Speaker = 3,
  CompositeAudioDevice = 4
}

export const enum CameraPosition {
  Unknown = 0,
  Front = 1,
  Back = 2,
  External = 3,
  LeftFront = 4,
  RightFront = 5
}

export const enum SharingSourceType {
  Monitor = 1,
  Window = 2
}

export const enum HolographicInteractionState {
  Idle = 0,     // Interaction hasn't been started
  Started = 1,  // Interaction start has been requested, but the data channel isn't active yet
  Active = 2    // Data channel is active and annotations can be sent
}

export type DeviceId = string;

export interface DeviceDesc {
  id: DeviceId;
  browserId?: DeviceId;
  label: string;
  kind: DeviceType;
}

export interface AudioDeviceDesc extends DeviceDesc {
  isSystemDefault: boolean;
}

export interface VideoDeviceDesc extends DeviceDesc {
  position: CameraPosition;
}

export const enum CompositeAudioDeviceFormFactor {
  Unknown = 0,
  Speakers = 1,
  Headphones = 2,
  Headset = 3,
  Handset = 4,
  Speakerphone = 5,
}

export interface CompositeAudioDeviceDesc extends DeviceDesc {
  microphoneId: DeviceId;
  speakerId: DeviceId;
  formFactor: CompositeAudioDeviceFormFactor;
}

export type SelectedDevices = {
  microphone?: DeviceId;
  speaker?: DeviceId;
  camera?: DeviceId;
}

export type DeviceAccess = {
  audio: boolean;
  video: boolean;
}

export interface IDeviceManagerEvents {
  devicesChanged: (devices: DeviceDesc[]) => void;
}

export interface IDeviceManager extends IObservableObject<IDeviceManagerEvents> {
  readonly isAudioOutputSelectionSupported: boolean;
  askDevicePermission(constraints?: DeviceAccess): Promise<DeviceAccess>;
  enumerateDevicesAsync(): Promise<DeviceDesc[]>;
  selectDevices(devices: SelectedDevices): void;
  enableTtySupport(enable: boolean): Promise<void>;
  getSelectedDevices(): SelectedDevices;
  createPreviewRenderer(target: IRenderTarget, options?: StartStreamOptions): Promise<IRenderer>;
  createScreenSharingPreviewRenderer(target: IRenderTarget, options?: StartStreamOptions): Promise<IRenderer>;
  getDeviceNameAsync(deviceId: DeviceId): Promise<string>;
}

export interface Rectangle {
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface ISharingSource {
  getId(): number;
  getType(): SharingSourceType;
  getPreviewAsync(width?: number, height?: number, asImage?: boolean): Promise<ImageData>;
  getDescription(): string;
  getIcon(width?: number, height?: number, asImage?: boolean): Promise<ImageData>;
  getBounds(): Rectangle;
}

export interface IScreenSharingManagerEvents {
  screensChanged: () => void;
}

export interface IScreenSharingManager extends IObservableObject<IScreenSharingManagerEvents> {
  enumerateScreensAsync(): Promise<ISharingSource[]>;
  enumerateWindowsAsync(): Promise<ISharingSource[]>;
}

export interface ISetup {
  setString(key: string, value: string): Promise<void>;
  setNumber(key: string, value: number): Promise<void>;
  getString(key: string): Promise<string>;
  getNumber(key: string): Promise<number>;
  delete(key: string): Promise<void>;
}

// ecsBlob: JSON formatted blob from ECS
// etag: ECS etag
export interface EcsConfig {
  ecsBlob: string;
  userIdentity: string;
  etag: string;
}

export interface IEcsProvider {
  setEcsConfig(config: EcsConfig): Promise<void>;
  getEcsQueryParameters(): Promise<string>;
}

export interface ICallingStackError extends Error {
  readonly callSupport: CallSupport;
}

export interface ICallingStack {
  fireIntent(intent: CallingIntent, identity?: string): void;
  getCallRegistry(): ICallRegistry;
  getDeviceManager(): IDeviceManager;
  getScreenSharingManager(): IScreenSharingManager;
  getSetup(): ISetup;
  getEcsProvider(): IEcsProvider;
}

export interface CallingLoggerPrefixFunction { (): string; }

export interface CallingLogger {
  createChild(namespace: string | CallingLoggerPrefixFunction, debug?: boolean): CallingLogger;
  log(...values: any[]): void;
  debug(...values: any[]): void;
  info(...values: any[]): void;
  warn(...values: any[]): void;
  error(...values: any[]): void;
}

export interface ICallTransferContext<T> {
  transferorMri: string;
  targetMri: string;
  context: T;
}

export interface CallTransferInfo<T> {
  transferContext: ICallTransferContext<T>;
  onCompleted(code: TerminatedReason): void;
}

export interface IMediaDataChannelEvents {
  stateChange(state: MediaDataChannelState): () => void;
}

export interface IMediaDataChannel {
  start(): Promise<void>;
  stop(): Promise<void>;
}

export interface IScreenSharingControlEvents {
  sharingRendererClicked: () => void;
  sharingRendererMouseEntering: () => void;
  sharingRendererMouseLeaving: () => void;
  sharingControlCapable: (capability: SharingControlCapability) => void;
  sharingIncomingControlRequest: (id: string) => void;
  sharingIncomingControlRequestCancelled: (id: string) => void;
  sharingControlChanged: (controlInfo: SharingControlInfo) => void;
  sharingControlError: (error: SharingControlError) => void;
  controlAvailableHandshake: (handshakeId: string, sourceId: number, status: AvailableHandshakeStatus, reason?: AvailableHandshakeTerminatedReason) => void;
  controlDataChannelStateChanged: (channelStatus: { id: number, state: MediaDataChannelState, readyForControl: boolean }) => void;
}

export interface IScreenSharingControl extends IObservableObject<IScreenSharingControlEvents> {

  controlState: ControlState;
  role: SharingControlRole;
  enableScreenSharingControl(enabled: boolean, reason?: SharingControlDisableReason, detail?: any): void;
  setScreenSharingControlFeatureFlag(enabled: boolean): void;
  isScreenSharingControlEnabled(): boolean;
  setRenderer(renderer: any): Promise<void>;
  setPointerImage(participant: ICallParticipant, base64img: string): Promise<void>;
  startPointerMode(): Promise<void>;
  stopPointerMode(): Promise<void>;
  requestControl(): Promise<void>;
  acceptControlRequest(): Promise<void>;
  denyControlRequest(): Promise<void>;
  grantControl(participant: ICallParticipant): Promise<void>;
  terminateControl(): Promise<void>;
}

export const enum HolographicInteractionMode {
  Arrows = 0,
  Drawing = 1,
}

export const enum HolographicInteractionTerminatedReason {
  ControlDevicesDetached = 0,
  VideoDisabled = 1,
  BloomOut = 2,
}

export interface IHolographicInteractionControlEvents {
  interactionReady: () => void;
  interactionEnabled: () => void;
  interactionDisabled: () => void;
  interactionTerminated: (terminatedReason: HolographicInteractionTerminatedReason) => void;
  arrowPlace: (requestId: number, xPos: number, yPos: number, color: number) => void;
  inkingStart: (requestId: number, xPos: number, yPos: number, color: number) => void;
  inkingInProgress: (requestId: number, xPos: number, yPos: number) => void;
  inkingStop: () => void;
  annotationCreated: (ownerId: number, requestId: number, annotationId: number, type: number, positionX: number, positionY: number, scale: number, angleInDegrees: number, color: number) => void;
  annotationModified: (ownerId: number, requestId: number, annotationId: number, type: number, positionX: number, positionY: number) => void;
  annotationRemoved: (ownerId: number, requestId: number, annotationId: number, isPermanent: boolean) => void;
}

/**
 * Describes available operations on a holographic interactions enabled call.
 *
 * holographic interactions contoller is a generic controller that allows the client to send
 * annotations to remote end on the hololens device.
 */

export interface IHolographicInteractionControl extends IObservableObject<IHolographicInteractionControlEvents>  {
  state: HolographicInteractionState;
  mode: HolographicInteractionMode;
  color: number;
  setFeatureFlag(enabled: boolean): void;
  startHolographicInteraction(renderer: IRenderer): Promise<void>;
  stopHolographicInteraction(): Promise<void>;
  setParticipant(callParticipant: ICallParticipant): void;
  removeParticipant(callParticipant: ICallParticipant): void;

  // manage sending annotations
  enableAnnotations(frameContainer: HTMLElement): Promise<IDisposable>;
  disableAnnotations(): Promise<void>;

  switchToArrows(): Promise<void>;
  switchToDrawing(): Promise<void>;

  deleteAnnotations(requestIds: number[], isPermanent: boolean): Promise<void>;
  deleteAllAnnotations(): Promise<void>;
  recoverAnnotations(requestIds: number[]): Promise<void>;
}

/**
 * Describes available operations on a Content Sharing session.
 *
 * Content Sharing contoller is a generic controller that allows clients to send
 * content between themselves. The controller and interfaces are somewhat general, but the
 * first usecase will be Document Sharing via WAC service
 */
export interface IContentSharingSession extends IObservableObject<{}> {
  // The metadata for the session
  contentSharingState: string;

  // The status for the session (connecting, presenting etc.)
  contentSharingStatus: ContentSharingStatus;

  // Content sharing termination reason. Provides additional debug content when session disconnects
  contentSharingTerminationReason: SessionTerminatedReason;

  // The identity for the session. For instance could be the WAC URL for a doc sharing session
  contentSharingIdentity: string;

  // Unique identifier for the session
  contentSharingGuid: string;

  /**
   * Starts a content sharing session.
   * Each implementation should cache all the start required parameters in their constructor
   */
  startContentSharing(): Promise<void>;

  /**
   * Join an incomming content sharing session
   */
  joinContentSharing(): Promise<void>;

  /**
   * Update ContentSharing session state
   */
  updateContentSharingSessionState(id: string, sessionState: string): Promise<void>;

  /**
   * Take control of the Content Sharing session
   */
  takeContentSharingControl(): Promise<void>;

  /**
   * Update self-participant ContentSharing state to Viewer
   */
  updateContentSharingParticipantStateToViewer(): Promise<void>;

  /**
   * Stop ContentSharing session for this endpoint
   */
  stopContentSharing(): Promise<void>;

  /**
   * Delete ContentSharing session for all endpoints
   */
  deleteContentSharing(): Promise<void>;
}

export const enum ParticipantContentSharingRole {
  None = 0,
  Attendee = 1,
  Presenter = 2,
}
export const enum ContentSharingStatus {
  None = 0,
  Connecting = 1,
  Ringing = 2,
  Presenting = 3,
  Connected = 4,
  Viewing = 5,
  Finishing = 6,
  Done = 7,
  Failed = 8,
}

export const enum MediaDataChannelState {
  Unknown,
  Available,
  Starting,
  Active,
  Stopping,
  NotStarted
}

export const enum SharingControlRole {
  Unknown,
  Sharer,
  Viewer
}

export interface SharingControlInfo {
  inControl: boolean;
  id: string;
  terminatedReason?: ControlTerminatedReason;
}

export interface SharingControlCapability {
  capable: boolean;
  id: string;
}

export const enum AvailableHandshakeStatus {
  Unknown,
  Sending,
  Resending,
  Acking,
  Dropping,
  Succeeded,
  Terminated
}

export const enum AvailableHandshakeTerminatedReason {
  Unknown,
  Succeeded,
  Shutdown,
  DataChannel,
  Replaced,
  TimedOut,
  UnknownSender
}

export const enum SharingControlErrorReason {
  SetInjectorConfigError,
  InjectRawInputError,
  SetInjectionRectError,
  AllowSingleControllerError,
  AvailableAckTimeout,
  SendDataError,
  DataChannelInactive
}

export const enum SharingControlDisableReason {
  SetInjectionFailed,
  DisabledDWM
}

// JSON format details
export interface SharingControlError {
  reason: SharingControlErrorReason,
  detail?: string;
}

} // declare module skype.calling

declare module "skype-calling-interface" {
    import ExportedNamespace = skype.calling;
    export = ExportedNamespace;
} // declare module "skype-calling-interface"
